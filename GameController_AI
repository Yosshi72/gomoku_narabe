using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GameController_AI : MonoBehaviour
{
    public int game_count = 8;

    private const int OPEN_FOUR = 0;
    private const int CLOSE_FOUR = 1;
    private const int OPEN_THREE = 2;
    private const int CLOSE_THREE =3;
    private const int OPEN_TWO = 4;
    private const int CLOSE_TWO = 5;
    private const int FIVE = 6;

    private int[] EvalValues = new int[7] { 2000, 10, 10, 4, 4, 2, 100 };
    private int[] enemyEvalValues = new int[7] { 4000, 30, 30, 8, 8, 2, 100 };

    private float INFINITYVAL=32000;
    public int WINNING = 30000;
    public int MAXDEPTH = 1;
    public int size = 15;
    public int[,] squares = new int[16,16];
    private int nextZ, nextX;

    private const int EMPTY = 0;
    private const int WHITE= 1;
    private const int BLACK = -1;

    public int BLACK_AI = 0;
    public int WHITE_AI = 1;

    private int currentPlayer = BLACK;
    private int PlayerColor;

    private Camera camera_object;
    private RaycastHit hit;

    public GameObject whiteStone;
    public GameObject blackStone;

    private int flag = 0;

   
    public int[,] potentialEvaluation = new int[15, 15]
        {//   0  1  2  3  4  5  6  7  8  9  10 11 12 13 14
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//0
            { 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0 },//1
            { 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0 },//2
            { 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0 },//3
            { 0, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 0 },//4
            { 0, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 0 },//5
            { 0, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 0 },//6
            { 0, 2, 2, 2, 5, 5, 5, 10, 5, 5, 5, 2, 2, 2, 0 },//7
            { 0, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 0 },//8
            { 0, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 0 },//9
            { 0, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 0 },//10
            { 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0 },//11
            { 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0 },//12
            { 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0 },//13
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//14
        };
    private int blackOpenFour;      // * B B B B *
    private int blackClosedFour;    // (W B B B B *) or (E B B B B *)
    private int blackOpenThree;     // * B B B *
    private int blackClosedThree;   // (W B B B *) or(E B B B *)
    private int blackOpenTwo;       //  * B B *
    private int blackClosedTwo;     //  (W B B *) or (E B B *)
    private int whiteOpenFour;      //
    private int whiteClosedFour;    //
    private int whiteOpenThree;     // 
    private int whiteClosedThree;   // 
    private int whiteOpenTwo;       // 
    private int whiteClosedTwo;		// 
    // Start is called before the first frame update


    void Start()
    {
        Random.InitState(System.DateTime.Now.Millisecond);
        camera_object = GameObject.Find("Camera").GetComponent<Camera>();
        InitializeArray();
        //DebugArray();
    }

    // Update is called once per frame
    void Update()
    {
        if (currentPlayer == WHITE && WHITE_AI == 1)
        {
            if (flag == 1)
            {
                if (game_count > 0)
                {
                    game_count--;
                    InitializeArray();
                    GameObject[] destroy = GameObject.FindGameObjectsWithTag("Stone");
                    foreach (GameObject stone in destroy)
                    {
                        Destroy(stone);
                    }
                    flag = 0;
                }
                else
                {
                    return;
                }
            }
            decideAIMove(currentPlayer);
            int z = nextZ;
            int x = nextX;
            if (squares[z, x] == EMPTY)
            {
                squares[z, x] = WHITE;
                GameObject stone = Instantiate(whiteStone);
                stone.transform.position = new Vector3(x, 0.3f, z);
                currentPlayer = BLACK;
                Debug.Log("Player2 : " + z + ", " + x);
            }
            if (CheckStone(WHITE, z, x) || CheckStone(BLACK, z, x))
            {
                flag = 1;
            }
        }
        else if (currentPlayer == BLACK && BLACK_AI == 1)
        {
            if (flag == 1)
            {
                if (game_count > 0)
                {
                    game_count--;
                    InitializeArray();
                    GameObject[] destroy = GameObject.FindGameObjectsWithTag("Stone");
                    foreach (GameObject stone in destroy)
                    {
                        Destroy(stone);
                    }
                    flag = 0;
                }
                else
                {
                    return;
                }
            }
            decideAIMove(currentPlayer);
            int z = nextZ;
            int x = nextX;
            if (squares[z, x] == EMPTY)
            {
                squares[z, x] = BLACK;
                GameObject stone = Instantiate(blackStone);
                stone.transform.position = new Vector3(x, 0.3f, z);
                currentPlayer = WHITE;
                Debug.Log("Player1 : " + z + ", " + x);
                if (CheckStone(WHITE, z, x) || CheckStone(BLACK, z, x))
                {
                    flag = 1;
                }
            }
        }
        if (Input.GetMouseButtonDown(0))
        {
            if (flag==1)
            {
                if (game_count > 0)
                {
                    game_count--;
                    InitializeArray();
                    GameObject[] destroy = GameObject.FindGameObjectsWithTag("Stone");
                    foreach(GameObject stone in destroy)
                    {
                        Destroy(stone);
                    }
                    flag = 0;
                }
                else
                {
                    return;
                }
                
            }
            Ray ray = camera_object.ScreenPointToRay(Input.mousePosition);

            if(Physics.Raycast(ray,out hit))
            {
                int x = (int)hit.collider.gameObject.transform.position.x;
                int z = (int)hit.collider.gameObject.transform.position.z;
                if (squares[z, x] == EMPTY)
                {
                    if (currentPlayer == WHITE && WHITE_AI==0)
                    {
                        squares[z,x] = WHITE;
                        GameObject stone = Instantiate(whiteStone);
                        stone.transform.position =new Vector3(x,0.3f,z);
                        currentPlayer = BLACK;
                        Debug.Log("Player2 : " + z + ", " + x);
                    }
                    else if (currentPlayer == BLACK && BLACK_AI==0)
                    {
                        squares[z, x] = BLACK;
                        GameObject stone = Instantiate(blackStone);
                        stone.transform.position = new Vector3(x, 0.3f, z) ;
                        currentPlayer = WHITE;
                        Debug.Log("Player1 : " + z + ", " + x);
                    }
                }
                if (CheckStone(WHITE, z, x) || CheckStone(BLACK, z, x))
                {
                    flag = 1;
                }
            }
        }
    }

    public void InitializeArray()
    {
        for (int i = 0; i < size; ++i)
        {
            for (int j = 0; j < size; ++j)
            {
                squares[i, j] = EMPTY;
            }
        }
    }

    public void DebugArray()
    {
        for (int i = 0; i < size; ++i)
        {
            for (int j = 0; j < size; ++j)
            {
                Debug.Log("(i,j)=(" + i + "," + j + ")=" + squares[i, j]);
            }
        }
    }
    private bool CheckStone(int color,int z,int x)
    {
        int count = 0;

        //row judge
        for(int i = 0; i < size; ++i)
        {
            for(int j = 0; j < size; ++j)
            {
                if(squares[i,j]==EMPTY || squares[i,j] != color)
                {
                    count = 0;
                }
                else
                {
                    count++;
                }
                if (count == 5)
                {
                    if (color == WHITE)
                    {
                        Debug.Log("Player1 won!!");
                    }
                    else
                    {
                        Debug.Log("Player2 won!!");
                    }
                    return true;
                }
            }
        }
        //column judge
        count = 0;
        for (int i = 0; i < size; ++i)
        {
            for (int j = 0; j < size; ++j)
            {
                if (squares[j, i] == EMPTY || squares[j, i] != color)
                {
                    count = 0;
                }
                else
                {
                    count++;
                }
                if (count == 5)
                {
                    if (color == WHITE)
                    {
                        Debug.Log("Player1 won!!");
                    }
                    else
                    {
                        Debug.Log("Player2 won!!");
                    }
                    return true;
                }
            }
        }

        count = 0;
        int c = -4;
        while (c!=5)
        {
            if((z + c>=0 && x + c >= 0) && (z + c < size && x + c < size))
            {
                if(squares[z+c,x+c]==EMPTY || squares[z + c, x + c] != color)
                {
                    count = 0;
                }
                else
                {
                    count++;
                }
                if (count == 5)
                {
                    if (color == WHITE)
                    {
                        Debug.Log("Player1 won!!");
                    }
                    else
                    {
                        Debug.Log("Player2 won!!");
                    }
                    return true;
                }
            }
            ++c;
        }
        count = 0;
        c = -4;
        while (c != 5)
        {
            if ((z + c >= 0 && x - c >= 0) && (z + c < size && x - c < size))
            {
                if (squares[z + c, x - c] == EMPTY || squares[z + c, x - c] != color)
                {
                    count = 0;
                }
                else
                {
                    count++;
                }
                if (count == 5)
                {
                    if (color == WHITE)
                    {
                        Debug.Log("Player1 won!!");
                    }
                    else
                    {
                        Debug.Log("Player2 won!!");
                    }
                    return true;
                }
            }
            ++c;
        }
        return false;
    }

    private void decideAIMove(int color)
    {
        float score;
        PlayerColor = color;
        score = alphaBetaSearch(0, PlayerColor, -INFINITYVAL, INFINITYVAL);
        //score = evaluate(color, color, 0);
        
    }

    private int miniMaxSearch(int depth,int color)
    {
        return 0;
    }
    private float alphaBetaSearch(int depth,int color,float alpha,float beta)
    { 
        float score, eval;
        
        if (depth == MAXDEPTH)
        {
            return evaluate(PlayerColor, color, depth);
        }
        if (color == PlayerColor)
        {
            score = -INFINITYVAL;
        }
        else
        {
            score = INFINITYVAL;
        }
        for(int i = 0; i < size; ++i)
        {
            for(int j = 0; j < size; ++j)
            {
                if (squares[i, j] == EMPTY)
                {
                    squares[i, j] = color;
                    if (CheckStone(color, i, j) == true)
                    {
                        if (PlayerColor == color)
                        {
                            squares[i, j] = EMPTY;
                            if (depth == 0)
                            {
                                nextX = j;
                                nextZ = i;
                            }
                            return WINNING - depth;
                        }
                        else
                        {
                            squares[i, j] = EMPTY;
                            return -(WINNING - depth);
                        }
                    }
                    else
                    {
                        eval = alphaBetaSearch(depth + 1, color * (-1), alpha, beta);
                        if(eval>0){
                            Debug.Log("Score: " + eval+" i: "+i+",j: "+j);
                        }
                        
                        squares[i, j] = EMPTY;
                        if (PlayerColor == color)
                        {
                            if (eval > score)
                            {
                                score = eval;
                                if (depth == 0)
                                {
                                    nextX = j;
                                    nextZ = i;
                                }
                            }
                            if (score >= beta)
                            {
                                return score;
                            }
                            if (score > alpha)
                            {
                                alpha = score;
                            }
                        }
                       
                        else
                        {
                            if (eval < score)
                            {
                                score = eval;
                            }

                            if (score <= alpha)
                            {
                                return score;
                            }
                            if (score > beta)
                            {
                                beta = score;
                            }
                        }
                    }
                }
            }
        }
        return score;
    }
    
    private float evaluate(int side,int nextcolor,int depth)
    {
        float eval = 0f;

        blackOpenFour = 0;
        blackClosedFour = 0;
        blackOpenThree = 0;
        blackClosedThree = 0;
        blackOpenTwo = 0;
        blackClosedTwo = 0;
        whiteOpenFour = 0;
        whiteClosedFour = 0;
        whiteOpenThree = 0;
        whiteClosedThree = 0;
        whiteOpenTwo = 0;
        whiteClosedTwo = 0;


        for(int i = 0; i< size; ++i)
        {
            for(int j = 0; j < size; ++j)
            {
                if (squares[i,j] == BLACK)
                {
                    stone_search(BLACK,i,j);
                }
                else if (squares[i, j] == WHITE)
                {

                    stone_search(WHITE,i,j);
                }
                if(side==BLACK && squares[i,j] == BLACK)
                {
                    eval += potentialEvaluation[i,j];
                }
                else if(side==WHITE && squares[i,j] == WHITE)
                {
                    eval -= potentialEvaluation[i, j];
                }
            }
        }

        int rand = Random.Range(0, 5);
        eval += (rand % 5);

        if(side==BLACK){
            eval += blackOpenFour * EvalValues[OPEN_FOUR]-whiteOpenFour*enemyEvalValues[OPEN_FOUR];
            eval += blackClosedFour * EvalValues[CLOSE_FOUR]-whiteClosedFour*enemyEvalValues[CLOSE_FOUR];
            eval += blackOpenThree  * EvalValues[OPEN_THREE]-whiteOpenThree*enemyEvalValues[OPEN_THREE];
            eval += blackClosedThree * EvalValues[CLOSE_THREE]-whiteClosedThree*enemyEvalValues[CLOSE_THREE];
            eval += blackOpenTwo * EvalValues[OPEN_TWO]-whiteOpenTwo*enemyEvalValues[OPEN_TWO];
            eval += blackClosedTwo * EvalValues[CLOSE_TWO]-whiteClosedTwo*enemyEvalValues[CLOSE_TWO];
        }
        else if(side==WHITE){
            eval*=-1;
            eval += whiteOpenFour * EvalValues[OPEN_FOUR]-blackOpenFour*enemyEvalValues[OPEN_FOUR];
            eval += whiteClosedFour * EvalValues[CLOSE_FOUR]-blackClosedFour*enemyEvalValues[CLOSE_FOUR];
            eval += whiteOpenThree  * EvalValues[OPEN_THREE]-blackOpenThree*enemyEvalValues[OPEN_THREE];
            eval += whiteClosedThree * EvalValues[CLOSE_THREE]-blackClosedThree*enemyEvalValues[CLOSE_THREE];
            eval += whiteOpenTwo * EvalValues[OPEN_TWO]-blackOpenTwo*enemyEvalValues[OPEN_TWO];
            eval += whiteClosedTwo * EvalValues[CLOSE_TWO]-blackClosedTwo*enemyEvalValues[CLOSE_TWO];
        }
        
        return eval;
    }

void stone_search(int color,int i,int j){
    int connect_num;
    int expected_emp_num;
    int blocked;
    int countZ,countX;
    //North_East
    connect_num = 1;
    expected_emp_num = 0;
    if((i==0 || j==0) &&(i>0 && j>0 && squares[i - 1, j - 1] == WHITE)){
        blocked = 1;
    }
    else
    {
        blocked = 0;
        expected_emp_num ++;
    }
    for (countZ = i + 1, countX = j + 1; countZ < size && countX < size; countZ++,countX++){
        if (squares[countZ,countX] == BLACK)
        {
            connect_num++;
        }
        else if (squares[countZ,countX] == WHITE)
        {
            blocked++;
            break;
        }
        else
        {
            break;
        }
    }
    if(blocked<=1 && connect_num > 1)
    {
        for(;countZ<size && countX < size && squares[countZ,countX]==EMPTY; ++countZ, ++countX)
        {
            expected_emp_num++;
        }
    }
    Connect(color,connect_num, blocked, expected_emp_num);

    //East
    connect_num = 1;
    expected_emp_num = 0;
    if (i == 0  && (i > 0 && squares[i - 1, j] == WHITE)){
        blocked = 1;
    }
    else
    {
        blocked = 0;
        expected_emp_num++;
    }
    countX = j;
    for (countZ = i + 1; countZ < size; countZ++)
    {
        if (squares[countZ,countX] == BLACK)
        {
            connect_num++;
        }
        else if (squares[countZ,countX] == WHITE)
        {
            blocked++;
            break;
        }
        else
        {
            break;
        }
    }
    if (blocked <= 1 && connect_num > 1)
    {
        for (; countZ < size && squares[countZ,countX]==EMPTY; ++countZ)
        {
            expected_emp_num++;
        }
    }
    Connect(color,connect_num, blocked, expected_emp_num);

    //South_East
    connect_num = 1;
    expected_emp_num = 0;
    if ((i == 0 || j == size-1) && (i > 0 && j <size-1 && squares[i - 1, j + 1] == WHITE)){
        blocked = 1;
    }
    else
    {
        blocked = 0;
        expected_emp_num++;
    }
    for (countZ = i + 1, countX = j - 1; countZ < size && countX>=0; countZ++, countX--)
    {
        if (squares[countZ, countX] == BLACK)
        {
            connect_num++;
        }
        else if (squares[countZ, countX] == WHITE)
        {
            blocked++;
            break;
        }
        else
        {
            break;
        }
    }
    if (blocked <= 1 && connect_num > 1)
    {
        for (; countZ < size && countX>=0 && squares[countZ, countX] == EMPTY; ++countZ, --countX)
        {
            expected_emp_num++;
        }
    }
    Connect(color,connect_num, blocked, expected_emp_num);

    //South
    connect_num = 1;
    expected_emp_num = 0;
    if ((j == size - 1) && (j < size - 1 && squares[i , j + 1] == WHITE)){
        blocked = 1;
    }
    else
    {
        blocked = 0;
        expected_emp_num++;
    }
    for (countX = j - 1; countX >= 0; countX--)
    {
        if (squares[countZ, countX] == BLACK)
        {
            connect_num++;
        }
        else if (squares[countZ, countX] == WHITE)
        {
            blocked++;
            break;
        }
        else
        {
            break;
        }
    }
    if (blocked <= 1 && connect_num > 1)
    {
        for (; countX >= 0 && squares[countZ, countX] == EMPTY; --countX)
        {
            expected_emp_num++;
        }
    }
    Connect(color,connect_num, blocked, expected_emp_num);

    //South_West
    connect_num = 1;
    expected_emp_num = 0;
    if ((i == size || j == size-1) && (i <size-1 && j <size-1 && squares[i + 1, j + 1] == WHITE)){
        blocked = 1;
    }
    else
    {
        blocked = 0;
        expected_emp_num++;
    }
    for (countZ = i - 1, countX = j - 1; countZ >=0 && countX>=0; countZ--, countX--)
    {
        if (squares[countZ, countX] == BLACK)
        {
            connect_num++;
        }
        else if (squares[countZ, countX] == WHITE)
        {
            blocked++;
            break;
        }
        else
        {
            break;
        }
    }
    if (blocked <= 1 && connect_num > 1)
    {
        for (; countZ>=0 && countX>=0 && squares[countZ, countX] == EMPTY; --countZ, --countX)
        {
            expected_emp_num++;
        }
    }
    Connect(color,connect_num, blocked, expected_emp_num);

    //West
    connect_num = 1;
    expected_emp_num = 0;
    if (i == size-1  && (i<size-1  && squares[i + 1, j] == WHITE)){
        blocked = 1;
    }
    else
    {
        blocked = 0;
        expected_emp_num++;
    }
    countX = j;
    for (countZ = i - 1; countZ >=0; countZ--)
    {
        if (squares[countZ,countX] == BLACK)
        {
            connect_num++;
        }
        else if (squares[countZ,countX] == WHITE)
        {
            blocked++;
            break;
        }
        else
        {
            break;
        }
    }
    if (blocked <= 1 && connect_num > 1)
    {
        for (; countZ >=0 && squares[countZ,countX]==EMPTY; --countZ)
        {
            expected_emp_num++;
        }
    }
    Connect(color,connect_num, blocked, expected_emp_num);

    //North_West
    connect_num = 1;
    expected_emp_num = 0;
    if((i==size-1 || j==0) &&(i<size-1 && j>0 && squares[i + 1, j - 1] == WHITE)){
        blocked = 1;
    }
    else
    {
        blocked = 0;
        expected_emp_num ++;
    }
    for (countZ = i - 1, countX = j + 1; countZ>=0 && countX < size; countZ--,countX++){
        if (squares[countZ,countX] == BLACK)
        {
            connect_num++;
        }
        else if (squares[countZ,countX] == WHITE)
        {
            blocked++;
            break;
        }
        else
        {
            break;
        }
    }
    if(blocked<=1 && connect_num > 1)
    {
        for(;countZ>=0 && countX < size && squares[countZ,countX]==EMPTY; --countZ, ++countX)
        {
            expected_emp_num++;
        }
    }
    Connect(color,connect_num, blocked, expected_emp_num);

    //North
    connect_num = 1;
    expected_emp_num = 0;
    if ((j == 0) && (j >0 && squares[i , j - 1] == WHITE)){
        blocked = 1;
    }
    else
    {
        blocked = 0;
        expected_emp_num++;
    }
    countZ=i;
    for (countX = j + 1; countX <size; countX++)
    {
        if (squares[countZ, countX] == BLACK)
        {
            connect_num++;
        }
        else if (squares[countZ, countX] == WHITE)
        {
            blocked++;
            break;
        }
        else
        {
            break;
        }
    }
    if (blocked <= 1 && connect_num > 1)
    {
        for (; countX <size && squares[countZ, countX] == EMPTY; ++countX)
        {
            expected_emp_num++;
        }
    }
    Connect(color,connect_num, blocked, expected_emp_num);
}
    void Connect(int color,int connect_num,int blocked, int openSquare)
    {
        if (blocked >= 2)
        {

        }
        else if (connect_num + openSquare < 5)
        {

        }
        else if (connect_num == 4)
        {
            if (blocked == 0)
            {
                if(color==BLACK){
                    blackOpenFour++;
                }
                else{
                    whiteOpenFour++;
                }
            }
            else if (blocked == 1)
            {
                if(color==BLACK){
                    blackClosedFour++;
                }
                else{
                    whiteClosedFour++;
                }
            }
        }
        else if (connect_num == 3)
        {
            if (blocked == 0)
            {
                if(color==BLACK){
                    blackOpenThree++;
                }
                else{
                    whiteOpenThree++;
                }
            }
            else if (blocked == 1)
            {
                if(color==BLACK){
                    blackClosedThree++;
                }
                else{
                    whiteClosedThree++;
                }
            }
        }
        else if (connect_num == 2)
        {
            if (blocked == 0)
            {
                if(color==BLACK){
                    blackOpenTwo++;
                }
                else{
                    whiteOpenTwo++;
                }
            }
            else if (blocked == 1)
            {
                if(color==BLACK){
                    blackClosedTwo++;
                }
                else{
                    whiteClosedTwo++;
                }
            }
        }
    }
}



