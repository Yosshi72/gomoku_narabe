using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

public class GameController_human : MonoBehaviour
{
    public int game_count = 8;

    private const int OPEN_FOUR = 0;
    private const int CLOSE_FOUR = 1;
    private const int OPEN_THREE = 2;
    private const int CLOSE_THREE =3;
    private const int OPEN_TWO = 4;
    private const int CLOSE_TWO = 5;
    private const int FIVE = 6;

    private int[] EvalValues = new int[7] { 2000, 10, 10, 4, 4, 2, 100 };
    private int[] enemyEvalValues = new int[7] { 4000, 30, 30, 8, 8, 2, 100 };

    private float INFINITYVAL=32000;
    private int WINNING = 30000;
    public int MAXDEPTH = 1;
    public int size = 15;
    public int[,] squares = new int[16,16];
    private int nextZ, nextX;

    private const int EMPTY = 0;
    private const int WHITE= 1;
    private const int BLACK = -1;

    public int BLACK_AI = 0;
    public int WHITE_AI = 0;

    private int currentPlayer = BLACK;
    private int PlayerColor;

    private Camera camera_object;
    private RaycastHit hit;

    public GameObject whiteStone;
    public GameObject blackStone;

    private int flag = 0;
    private int prohibit_flag=0;
    private int center_z=7;
    private int center_x=7;
    private int pre_z=7;
    private int pre_x=7;
    public int search_range=5;
    public int[,] potentialEvaluation = new int[15, 15]
        {//   0  1  2  3  4  5  6  7  8  9  10 11 12 13 14
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//0
            { 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0 },//1
            { 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0 },//2
            { 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0 },//3
            { 0, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 0 },//4
            { 0, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 0 },//5
            { 0, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 0 },//6
            { 0, 2, 2, 2, 5, 5, 5, 10, 5, 5, 5, 2, 2, 2, 0 },//7
            { 0, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 0 },//8
            { 0, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 0 },//9
            { 0, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 0 },//10
            { 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0 },//11
            { 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0 },//12
            { 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0 },//13
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//14
        };

    private int[] black_connect=new int[8]{0,0,0,0,0,0,0,0};
    private int open4=0;
    private int normal4=0;
    private int open3=0;
    private int normal3=0;
    // Start is called before the first frame update
    void Start()
    {
        Random.InitState(System.DateTime.Now.Millisecond);
        camera_object = GameObject.Find("Camera").GetComponent<Camera>();
        InitializeArray();
        //DebugArray();
    }

    // Update is called once per frame
    void Update()
    {
        //AI PLAY
        if (currentPlayer == WHITE && WHITE_AI == 1)
        {
            if (flag == 1 )
            {
                if (game_count > 0)
                {
                    game_count--;
                    InitializeArray();
                    GameObject[] destroy = GameObject.FindGameObjectsWithTag("Stone");
                    foreach (GameObject stone in destroy)
                    {
                        Destroy(stone);
                    }
                    flag = 0;
                }
                else
                {
                    return;
                }
            }
            decideAIMove(currentPlayer);
            int z = nextZ;
            int x = nextX;
            if (squares[z, x] == EMPTY)
            {
                squares[z, x] = WHITE;
                center_z=z;
                center_x=x;
                pre_z=z;
                pre_x=x;
                GameObject stone = Instantiate(whiteStone);
                stone.transform.position = new Vector3(x, 0.3f, z);
                currentPlayer = BLACK;
                // Debug.Log("Player2 : " + z + ", " + x);
            }
            if(flag==1){
                Debug.Log("Player2 won.");
            }
        }
        else if (currentPlayer == BLACK && BLACK_AI == 1)
        {
            if (flag == 1 || prohibit_flag==1)
            {
                if (game_count > 0)
                {
                    game_count--;
                    InitializeArray();
                    GameObject[] destroy = GameObject.FindGameObjectsWithTag("Stone");
                    foreach (GameObject stone in destroy)
                    {
                        Destroy(stone);
                    }
                    flag = 0;
                    prohibit_flag=0;
                }
                else
                {
                    return;
                }
            }
            decideAIMove(currentPlayer);
            int z = nextZ;
            int x = nextX;
            if (squares[z, x] == EMPTY)
            {
                center_z=z;
                center_x=x;
                pre_z=z;
                pre_x=x;
                squares[z, x] = BLACK;
                GameObject stone = Instantiate(blackStone);
                stone.transform.position = new Vector3(x, 0.3f, z);
                currentPlayer = WHITE;
                // Debug.Log("Player1 : " + x + ", " + z);
                if(prohibit_flag==1){
                    Debug.Log("Player2 won.");
                }
                if(flag==1){
                    Debug.Log("Player1 won.");
                }
            }
        }

        //HUMAN PLAY
        if (Input.GetMouseButtonDown(0))
        {
            if (flag==1 ||prohibit_flag==1)
            {
                if (game_count > 0)
                {
                    game_count--;
                    InitializeArray();
                    GameObject[] destroy = GameObject.FindGameObjectsWithTag("Stone");
                    foreach(GameObject stone in destroy)
                    {
                        Destroy(stone);
                    }
                    flag = 0;
                    prohibit_flag=0;
                }
                else
                {
                    return;
                }
                
            }
            Ray ray = camera_object.ScreenPointToRay(Input.mousePosition);

            if(Physics.Raycast(ray,out hit))
            {
                int x = (int)hit.collider.gameObject.transform.position.x;
                int z = (int)hit.collider.gameObject.transform.position.z;
                if (squares[z, x] == EMPTY)
                {
                    if (currentPlayer == WHITE && WHITE_AI==0)
                    {
                        center_z=z;
                        center_x=x;
                        pre_z=z;
                        pre_x=x;
                        squares[z,x] = WHITE;
                        GameObject stone = Instantiate(whiteStone);
                        stone.transform.position =new Vector3(x,0.3f,z);
                        currentPlayer = BLACK;
                        // Debug.Log("Player2 : " + z + ", " + x);
                        line_neighborhood(WHITE,z,x,5);
                        if(flag==1){
                            Debug.Log("Player2 won.");
                        }
                    }
                    else if (currentPlayer == BLACK && BLACK_AI==0)
                    {
                        center_z=z;
                        center_x=x;
                        pre_z=z;
                        pre_x=x;
                        squares[z, x] = BLACK;
                        GameObject stone = Instantiate(blackStone);
                        stone.transform.position = new Vector3(x, 0.3f, z) ;
                        currentPlayer = WHITE;
                        // Debug.Log("Player1 : " + z + ", " + x);
                        line_neighborhood(BLACK,z,x,5);
                        if(prohibit_flag==1){
                            Debug.Log("Player2 won.");
                        }
                        if(flag==1){
                            Debug.Log("Player1 won.");
                        }
                    }
                }
            }
        }
    }

    public void InitializeArray()
    {
        for (int i = 0; i < size; ++i)
        {
            for (int j = 0; j < size; ++j)
            {
                squares[i, j] = EMPTY;
            }
        }
    }

    public void DebugArray()
    {
        for (int i = 0; i < size; ++i)
        {
            for (int j = 0; j < size; ++j)
            {
                Debug.Log("(i,j)=(" + i + "," + j + ")=" + squares[i, j]);
            }
        }
    }
    private void decideAIMove(int color)
    {
        float score;
        PlayerColor = color;
        score = alphaBetaSearch(0, PlayerColor, -INFINITYVAL, INFINITYVAL,center_z,center_x,pre_z,pre_x);
        
    }

    private float alphaBetaSearch(int depth,int color,float alpha,float beta,int cz,int cx,int pz,int px)
    { 
        float score, eval;
        if (depth == MAXDEPTH)
        {
            return remake_evaluate(PlayerColor, (-1)*color, cz,cx,pz,px);
        }
        if (color == PlayerColor)
        {
            score = -INFINITYVAL;
        }
        else
        {
            score = INFINITYVAL;
        }
        for(int i = cz-search_range; i < cz+search_range+1; ++i)
        {
            for(int j = cx-search_range; j < cx+search_range+1; ++j)
            {
                if(i>=0 && i<size &&j>=0 && j<size){
                    if (squares[i, j] == EMPTY)
                    {
                        squares[i, j] = color;
                        if (flag==1)
                        {
                            if (PlayerColor == color)
                            {
                                squares[i, j] = EMPTY;
                                if (depth == 0)
                                {
                                    nextX = j;
                                    nextZ = i;
                                }
                                return WINNING - depth;
                            }
                            else
                            {
                                squares[i, j] = EMPTY;
                                return -(WINNING - depth);
                            }
                        }
                        else
                        {
                            eval = alphaBetaSearch(depth + 1, color * (-1), alpha, beta,i,j,cz,cx);
                            
                            
                            squares[i, j] = EMPTY;
                            if (PlayerColor == color)
                            {
                                if (eval > score)
                                {
                                    score = eval;
                                    if (depth == 0)
                                    {
                                        nextX = j;
                                        nextZ = i;
                                    }
                                }
                                if (score >= beta)
                                {
                                    return score;
                                }
                                if (score > alpha)
                                {
                                    alpha = score;
                                }
                            }
                        
                            else
                            {
                                if (eval < score)
                                {
                                    score = eval;
                                
                                if (score <= alpha)
                                {
                                    return score;
                                }
                                if (score > beta)
                                {
                                    beta = score;
                                }
                            }
                        }
                    }
                }
            }
        }
        return score;
    }
    private float remake_evaluate(int PlayerColor,int nextcolor,int now_i,int now_j,int pre_i,int pre_j){
        float eval=0f;
        init_count();
        eval+=potentialEvaluation[now_i,now_j];
        int rand = Random.Range(0, 5);
        eval += (rand % 5);
        line_neighborhood(nextcolor,now_i,now_j,5);
        if(prohibit_flag==1){
            eval-=INFINITYVAL;
            
            prohibit_flag=0;
        }
        if(flag==1){
            eval+=10*WINNING;
        }
        eval+=open4*20+(normal4+open3)*5+normal3*1;
        init_count();
        line_neighborhood(nextcolor*(-1),pre_i,pre_j,5);
        eval-=(open4*400+(normal4+open3)*15+normal3*2);
        if(PlayerColor!=nextcolor){
            return -eval;
        }
        return eval;
    }

    void line_neighborhood(int color,int i,int j,int N){
        int con1,con2,con3,con4;
        //↑
        StringBuilder connect1 =new StringBuilder();
        for(int c=0;c<2*N+1;++c){
            string str=assign_char(color,i-N+c,j);
            connect1.Append(str);
        }
        string c1=connect1.ToString();
        //→
        StringBuilder connect2 =new StringBuilder();
        for(int c=0;c<2*N+1;++c){
            string str=assign_char(color,i,j-N+c);
            connect2.Append(str);
        }
        string c2=connect2.ToString();
        //↗
        StringBuilder connect3 =new StringBuilder();
        for(int c=0;c<2*N+1;++c){
            string str=assign_char(color,i-N+c,j-N+c);
            connect3.Append(str);
        }
        string c3=connect3.ToString();

        //↘
        StringBuilder connect4 =new StringBuilder();
        for(int c=0;c<2*N+1;++c){
            string str=assign_char(color,i-N+c,j+N-c);
            connect4.Append(str);
        }
        string c4=connect4.ToString();
        if(color==BLACK){
            con1=judge_Blackconnect(c1);
            prohibit_judge(con1);
            con2=judge_Blackconnect(c2);
            prohibit_judge(con2);
            con3=judge_Blackconnect(c3);
            prohibit_judge(con3);
            con4=judge_Blackconnect(c4);
            prohibit_judge(con4);
            if(normal4+open4>=2){
                prohibit_flag=1;
            }
            if(open3>=2){
                prohibit_flag=1;
            }
        }
        if(color==WHITE){
            con1=judge_Whiteconnect(c1);
            con2=judge_Whiteconnect(c2);
            con3=judge_Whiteconnect(c3);
            con4=judge_Whiteconnect(c4);
            prohibit_judge(con1);
            prohibit_judge(con2);
            prohibit_judge(con3);
            prohibit_judge(con4);
        }
        // init_count();
        // Debug.Log(con1+", "+con2+", "+con3+", "+con4);
    }
    string assign_char(int color,int i,int j){
        if(i>=0 && i<size && j>=0 && j<size){
            if(squares[i,j]==WHITE){
                return "W";
            }
            else if(squares[i,j]==BLACK){
                return "B";
            }
            else if(squares[i,j]==EMPTY){
                return "E";
            } 
        }
        if(color==BLACK){
            return "W";
        }
        else{
            return "B";
        }
    }

    //0:5連, 1:両側空き4連, 2:4連, 3:両側空き３連, 4: 雰囲気的によさげ 5:その他, 6: 直線状4*2つ,7:6連
    //0:WIN, [6,7]:Prohibited, 1:リーチ
    int judge_Blackconnect(string str){
        string[] B4E1=new string[5]{"EBBBB","BEBBB","BBEBB","BBBEB","BBBBE"};
        string[] B3E1=new string[4]{"EEBBBE","EBEBBE","EBBEBE","EBBBEE"};
        string[] straight44=new string[3]{"BEBBBEB","BBEBBEBB","BBBEBEBBB"};

        bool five_B=Regex.IsMatch(str,"BBBBB");
        if(five_B){
            bool six_B=Regex.IsMatch(str,"BBBBBB");
            if(six_B){
                return 7;
            }
            return 0;
        }
        foreach(string ans in straight44){
            bool a=Regex.IsMatch(str,ans);
            if(a){
               return 6;
            }
        }
        bool open_four=Regex.IsMatch(str,"EBBBBE");
        if(open_four){
            bool essential_six0=Regex.IsMatch(str,"BEBBBBE");
            bool essential_six1=Regex.IsMatch(str,"EBBBBEB");
            if(!(essential_six0 || essential_six1)){
                return 1;
            }
        }
        foreach(string ans in B4E1){
            bool a=Regex.IsMatch(str,ans);
            if(a){
                bool a1=Regex.IsMatch(str,"B"+ans);
                bool a2=Regex.IsMatch(str,ans+"B");
                if(!(a1 ||a2)){
                    return 2;
                }
                
            }
        }
        foreach(string ans in B3E1){
            bool a=Regex.IsMatch(str,ans);
            if(a){
                bool a1=Regex.IsMatch(str,"B"+ans);
                bool a2=Regex.IsMatch(str,ans+"B");
                if(a1 ||a2){
                    return 4;
                }
                return 3;
            }
        }
        return 5;
    }
    //0: ５連, 1: 両開き４連, 2: ４連, 3:両開き3連　4: 雰囲気的によさげ　５；その他
    int judge_Whiteconnect(string str){
        string[] W4E1=new string[5]{"EWWWW","WEWWW","WWEWW","WWWEW","WWWWE"};
        string[] W3E1=new string[4]{"EWWW","WEWW","WWEW","WWWE"};
        bool five_W=Regex.IsMatch(str,"WWWWW");
        if(five_W){
            return 0;
        }
        bool open_four =Regex.IsMatch(str,"EWWWWE");
        if(open_four){
            return 1;
        }
        foreach(string str0 in W4E1){
            bool four=Regex.IsMatch(str,str0);
            if(four){
                return 2;
            }
        }
        foreach(string str0 in W3E1){
            bool open_three=Regex.IsMatch(str,"E"+str0+"E");
            if(open_three){
                return 3;
            }
            bool three=Regex.IsMatch(str,str0);
            if(three){
                return 4;
            }
        }
        bool two =Regex.IsMatch(str,"EWWE");
        if(two){
            return 4;
        }
        
        return 5;
    }
    void prohibit_judge(int num){
        switch(num){
            case 6:
            prohibit_flag=1;  break;
            case 7: 
            prohibit_flag=1; break;
            case 0:
            flag=1; break;
            case 1:
            open4++; break;
            case 2:
            normal4++; break;
            case 3:
            open3++; break;
            case 4:
            normal3++; break;
        }
    }
    void init_count(){
        open4=0;
        normal4=0;
        open3=0;
        normal3=0;
    }

}

